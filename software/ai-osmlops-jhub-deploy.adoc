---
sidebar: sidebar 
permalink: software/ai-osmlops-jhub-deploy.html 
keywords: AI, control plane, MLOps, JupyterHub 
summary: NetApp開源 MLOps - JupyterHub 部署 
---
= JupyterHub 部署
:hardbreaks:
:allow-uri-read: 
:nofooter: 
:icons: font
:linkattrs: 
:imagesdir: ../media/


[role="lead"]
本節介紹在 Kubernetes 叢集中部署 JupyterHub 必須完成的任務。


NOTE: 可以在 Kubernetes 以外的平台上部署 JupyterHub。在 Kubernetes 以外的平台上部署 JupyterHub 超出了本解決方案的範圍。



== 先決條件

在執行本節概述的部署練習之前，我們假設您已經執行了以下任務：

. 您已經有一個可以運行的 Kubernetes 叢集。
. 您已經在 Kubernetes 叢集中安裝並設定了NetApp Trident 。有關Trident的更多詳細信息，請參閱link:https://docs.netapp.com/us-en/trident/index.html["Trident文檔"^]。




== 安裝 Helm

JupyterHub 使用 Helm（Kubernetes 的熱門套件管理器）進行部署。在部署 JupyterHub 之前，您必須在 Kubernetes 控制節點上安裝 Helm。要安裝 Helm，請按照 https://helm.sh/docs/intro/install/["安裝說明"^]在 Helm 官方文件中。



== 設定預設 Kubernetes StorageClass

在部署 JupyterHub 之前，您必須在 Kubernetes 叢集中指定一個預設 StorageClass。若要在叢集中指定預設 StorageClass，請依照link:ai-osmlops-kubeflow-deploy.html["Kubeflow部署"]部分。如果您已經在叢集中指定了預設 StorageClass，則可以跳過此步驟。



== 部署 JupyterHub

完成上述步驟後，現在可以部署 JupyterHub 了。  JupyterHub 部署需要以下步驟：



=== 設定 JupyterHub 部署

在部署之前，最好先針對各自的環境最佳化 JupyterHub 部署。您可以建立一個 *config.yaml* 檔案並在使用 Helm 圖表部署期間使用它。

可以在以下位置找到範例 *config.yaml* 文件 https://github.com/jupyterhub/zero-to-jupyterhub-k8s/blob/HEAD/jupyterhub/values.yaml[]


NOTE: 在此 config.yaml 檔案中，您可以為NetApp Trident StorageClass 設定 *(singleuser.storage.dynamic.storageClass)* 參數。這是用於為各個使用者工作區配置磁碟區的儲存類別。



=== 新增共享磁碟區

如果您想要為所有 JupyterHub 使用者使用共享卷，您可以相應地調整您的 *config.yaml*。例如，如果您有一個名為 jupyterhub-shared-volume 的共用 PersistentVolumeClaim，則可以將其作為 /home/shared 掛載在所有使用者 pod 中，如下所示：

[source, shell]
----
singleuser:
  storage:
    extraVolumes:
      - name: jupyterhub-shared
        persistentVolumeClaim:
          claimName: jupyterhub-shared-volume
    extraVolumeMounts:
      - name: jupyterhub-shared
        mountPath: /home/shared
----

NOTE: 這是可選步驟，您可以根據需要調整這些參數。



=== 使用 Helm Chart 部署 JupyterHub

讓 Helm 了解 JupyterHub Helm 圖表儲存庫。

[source, shell]
----
helm repo add jupyterhub https://hub.jupyter.org/helm-chart/
helm repo update
----
這應該會顯示如下輸出：

[source, shell]
----
Hang tight while we grab the latest from your chart repositories...
...Skip local chart repository
...Successfully got an update from the "stable" chart repository
...Successfully got an update from the "jupyterhub" chart repository
Update Complete. ⎈ Happy Helming!⎈
----
現在透過從包含您的 config.yaml 的目錄執行以下命令來安裝由您的 config.yaml 設定的圖表：

[source, shell]
----
helm upgrade --cleanup-on-fail \
  --install my-jupyterhub jupyterhub/jupyterhub \
  --namespace my-namespace \
  --create-namespace \
  --values config.yaml
----

NOTE: 在此範例中：

<helm-release-name> 設定為 my-jupyterhub，這將是您的 JupyterHub 版本的名稱。 <k8s-namespace> 設定為 my-namespace，這是您要安裝 JupyterHub 的命名空間。如果命名空間不存在，則使用 --create-namespace 標誌建立命名空間。  --values 標誌指定包含所需設定選項的 config.yaml 檔案。



=== 檢查部署

在步驟 2 運行時，您可以透過以下命令看到正在建立的 pod：

[source, shell]
----
kubectl get pod --namespace <k8s-namespace>
----
等待 hub 和 proxy pod 進入 Running 狀態。

[source, shell]
----
NAME                    READY     STATUS    RESTARTS   AGE
hub-5d4ffd57cf-k68z8    1/1       Running   0          37s
proxy-7cb9bc4cc-9bdlp   1/1       Running   0          37s
----


=== 造訪 JupyterHub

尋找我們可以用來存取 JupyterHub 的 IP。執行以下命令，直到代理公共服務的 EXTERNAL-IP 可用，如範例輸出所示。


NOTE: 我們在 config.yaml 檔案中使用了 NodePort 服務，您可以根據您的設定（例如 LoadBalancer）調整您的環境。

[source, shell]
----
kubectl --namespace <k8s-namespace> get service proxy-public
----
[source, shell]
----
NAME           TYPE           CLUSTER-IP     EXTERNAL-IP     PORT(S)        AGE
proxy-public   NodePort   10.51.248.230   104.196.41.97   80:30000/TCP   1m
----
若要使用 JupyterHub，請在瀏覽器中輸入代理公共服務的外部 IP。
